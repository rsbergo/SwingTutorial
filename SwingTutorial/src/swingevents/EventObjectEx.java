package swingevents;

import javax.swing.AbstractAction;
import javax.swing.BorderFactory;
import javax.swing.DefaultListModel;
import javax.swing.GroupLayout;
import javax.swing.JButton;
import javax.swing.JComponent;
import javax.swing.JFrame;
import javax.swing.JList;
import java.awt.EventQueue;
import java.awt.event.ActionEvent;
import java.time.Instant;
import java.time.ZoneId;
import java.time.format.DateTimeFormatter;

/**
 * All GUI applications are event-driven. An application reacts to different even types which are generated during its
 * life. Events can be generated by the user of an application or by other means such as an Internet connection, a
 * window manager, or a timer.
 * 
 * In the event model there are three participants: the event source (the object whose state changes, generating
 * Events), the event object (encapsulates the state changes in the event source), and the event listener (the object
 * that wants to be notified). The event source object delegates the task of handling an event to the event listener.
 * 
 * Event handling in Java Swing uses Event Delegation Model: the objects that are to be notified when a specific event
 * occurs are specified.
 * 
 * When something happens in an application (click a button, select an item from a list, etc.), an event object is
 * created. There are several types of events, including ActionEvent, TextEvent, FocusEvent and ComponentEvent, each
 * created under specific conditions.
 * 
 * An event object holds information about an even that has occurred.
 * 
 * In this example, the ActionEvent is analyzed.
 */
public class EventObjectEx extends JFrame
{
    // Data Fields
    private JList myList;
    private DefaultListModel model;
    
    // Methods
    /**
     * Constructor.
     */
    public EventObjectEx()
    {
        initUI();
    }
    
    /**
     * Initialize the UI.
     */
    private void initUI()
    {
        model = new DefaultListModel();
        myList = new JList(model);
        myList.setBorder(BorderFactory.createEtchedBorder());
        
        var okBtn = new JButton("OK");
        okBtn.addActionListener(new ClickAction());
        
        createLayout(okBtn, myList);
        
        setTitle("Event object");
        setLocationRelativeTo(null);
        setDefaultCloseOperation(EXIT_ON_CLOSE);
    }
    
    /**
     * Create the layout.
     */
    private void createLayout(JComponent... arg)
    {
        var pane = getContentPane();
        var gl = new GroupLayout(pane);
        pane.setLayout(gl);
        
        gl.setAutoCreateContainerGaps(true);
        gl.setAutoCreateGaps(true);
        
        gl.setHorizontalGroup(gl.createSequentialGroup().addComponent(arg[0]).addComponent(arg[1], 250,
                GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE));
        
        gl.setVerticalGroup(gl.createParallelGroup().addComponent(arg[0]).addComponent(arg[1], 150,
                GroupLayout.PREFERRED_SIZE, GroupLayout.DEFAULT_SIZE));
        
        pack();
    }
    
    /**
     * ClickAction class
     */
    private class ClickAction extends AbstractAction
    {
        /**
         * The actionPerformed() method is invoked when an action occurs. Its parameter is an ActionEvent object.
         */
        @Override
        public void actionPerformed(ActionEvent e)
        {
            if (e.getID() == ActionEvent.ACTION_PERFORMED)
                model.addElement("Event Id: ACTION_PERFORMED");
            
            // Get the time when the event occurred. The getWhen() method returns time value in milliseconds. The value
            // is converted into a LocalTime and formatted into ISO time with DateTimeFormatter.
            var formatter = DateTimeFormatter.ISO_TIME;
            var localTime = Instant.ofEpochMilli(e.getWhen()).atZone(ZoneId.systemDefault()).toLocalTime();
            var text = localTime.format(formatter);
            model.addElement("Time: " + text);
            
            // Add the name of the source of the event to the list.
            var source = e.getSource().getClass().getName();
            model.addElement("Source: " + source);
            
            // Get the modifier keys using a bitwise-or of the modified constants.
            var mod = e.getModifiers();
            var buffer = new StringBuffer("Modifiers: ");
            if ((mod & ActionEvent.ALT_MASK) > 0)
                buffer.append("Alt ");
            if ((mod & ActionEvent.SHIFT_MASK) > 0)
                buffer.append("Shift ");
            if ((mod & ActionEvent.META_MASK) > 0)
                buffer.append("Meta ");
            if ((mod & ActionEvent.CTRL_MASK) > 0)
                buffer.append("Ctrl ");
            model.addElement(buffer);
        }
        
    }
    
    // Driver
    public static void main(String[] args)
    {
        EventQueue.invokeLater(() ->
        {
            var ex = new EventObjectEx();
            ex.setVisible(true);
        });
    }
    
}
